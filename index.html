<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>Parallel Coordinates</title>
    <style type="text/css">
    

svg {
  font: 10px sans-serif;
}

.background path {
  fill: none;
  stroke: #ccc;
  stroke-opacity: .4;
  shape-rendering: crispEdges;
}

.foreground path {
  fill: none;
  stroke-opacity: .7;
}

.brush .extent {
  fill-opacity: .3;
  stroke: #fff;
  shape-rendering: crispEdges;
}

.axis line, .axis path {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.axis text {
  text-shadow: 0 1px 0 #fff;
  cursor: move;
}

    </style>
  </head>
  <body>
    <script type="text/javascript" src="d3/d3.min.js"></script>
    <script src="topojson.min.js"></script>
    <script src="node_modules/datamaps/dist/datamaps.world.min.js"></script>
    <div id="slider"></div>
    <script src="d3.slider.js"></script>
    <link rel="stylesheet" href="d3.slider.css" />  
    <script>

      d3.select('#slider').call(d3.slider().axis(true).min(1997).max(2013).step(1).on("slide", function(ext, value) {
        year = value;
        updateMapByYear();
      }));
    </script>
    <div id="container" style="position: relative; width: 1100px; height: 900px;"></div>
    <script type="text/javascript">

      var countryNames = ["Algeria", "Angola", "Benin", "Botswana", "Burkina Faso", "Burundi", "Cameroon", "Chad", "Djibouti", "Egypt", "Equatorial Guinea", "Eritrea", "Ethiopia", "Gabon", "Gambia", "Ghana", "Guinea", "Guinea-Bissau", "Ivory Coast", "Kenya", "Lesotho", "Liberia", "Libya", "Madagascar", "Malawi", "Mali", "Mauritania", "Morocco", "Mozambique", "Namibia", "Niger", "Nigeria", "Republic of Congo", "Rwanda", "Senegal", "Sierra Leone", "Somalia", "South Africa", "South Sudan", "Sudan", "Swaziland", "Tanzania", "Togo", "Tunisia", "Uganda", "Zambia", "Zimbabwe"];

      var baseYear = 1997;
      var endYear = 2014;
      var yearRange = endYear - baseYear;

      var countryArray = {};

      var transitMatrix = {};

      // Country Codes

      var codes = {};
      codes["Algeria"] = "DZA";
      codes["Angola"] = "AGO";
      codes["Benin"] = "BEN";
      codes["Botswana"] = "BWA";
      codes["Burkina Faso"] = "BFA";
      codes["Burundi"] = "BDI";
      codes["Cameroon"] = "CMR";
      codes["Chad"] = "TCD";
      codes["Djibouti"] = "DJI";
      codes["Egypt"] = "EGY";
      codes["Equatorial Guinea"] = "GNQ";
      codes["Eritrea"] = "ERI";
      codes["Ethiopia"] = "ETH";
      codes["Gabon"] = "GAB";
      codes["Gambia"] = "GMB";
      codes["Ghana"] =  "GHA";
      codes["Guinea"] = "GIN";
      codes["Guinea-Bissau"] = "GNB";
      codes["Ivory Coast"] = "CIV";
      codes["Kenya"] = "KEN";
      codes["Lesotho"] = "LSO";
      codes["Liberia"] = "LBR";
      codes["Libya"] = "LBY";
      codes["Madagascar"] = "MDG";
      codes["Malawi"] = "MWI";
      codes["Mali"] = "MLI";
      codes["Mauritania"] = "MRT";
      codes["Morocco"] = "MAR";
      codes["Mozambique"] = "MOZ";
      codes["Namibia"] = "NAM"
      codes["Niger"] = "NER";
      codes["Nigeria"] = "NGA";
      codes["Republic of Congo"] = "COD";
      codes["Rwanda"] = "RWA";
      codes["Senegal"] = "SEN";
      codes["Sierra Leone"] = "SLE";
      codes["Somalia"] = "SOM";
      codes["South Africa"] = "ZAF";
      codes["South Sudan"] = "SSD";
      codes["Sudan"] = "SDN";
      codes["Swaziland"] = "SWZ";
      codes["Tanzania"] = "TZA";
      codes["Togo"] = "TGO";
      codes["Tunisia"] = "TUN";
      codes["Uganda"] = "UGA";
      codes["Zambia"] = "ZMB";
      codes["Zimbabwe"] = "ZWE";

      var longs = {};
      var lats = {};

      var year = 2005;

      var map = null;

      var dataset = {};
      var series = [];

      var arcs = [];

      var updateMapByYear = function() {
        dataset = {};
        series = [];
        countryNames.forEach(function(n) {
          var code = codes[n];
          var numberOfRefugees = countryArray[n].casualties[year];
          console.log(countryArray[n].casualties[year]);
          series.push([code, numberOfRefugees]);
        });

        var onlyValues = series.map(function(obj){ return obj[1]; });
        var minValue = Math.min.apply(null, onlyValues), maxValue = Math.max.apply(null, onlyValues);

        // color palette
        var paletteScale = d3.scale.linear()
                .domain([minValue,maxValue])
                .range(["#EFEFFF","#02386F"]);

        series.forEach(function(item){ //
            var iso = item[0], value = item[1];
            dataset[iso] = { numberOfThings: value, fillColor: paletteScale(value) };
        });

        var toRemove = document.getElementById('container');
        toRemove.parentNode.removeChild(toRemove);

        var div = document.createElement('div');
        document.body.appendChild(div);
        div.id = 'container';
        div.style = "position: relative; width: 1100px; height: 900px;";

        var map = new Datamap({
          element: document.getElementById('container'),
          projection: 'mercator',
          fills: { defaultFill: '#F5F5F5' },
          data: dataset,
          geographyConfig: {
              borderColor: '#DEDEDE',
              highlightBorderWidth: 2,
              // don't change color on mouse hover
              highlightFillColor: function(geo) {
                  return geo['fillColor'] || '#F5F5F5';
              },
              // only change border
              highlightBorderColor: '#B7B7B7'
          }
        });
      }

    d3.csv("conflictSize.csv", function(conflicts) {

      for(var i = 0; i < countryNames.length; i++) {
        var country = {};
        country.code = null;
        country.casualties = {};

        for(var j = 0; j < yearRange; j++) {
          country.casualties[baseYear + j] = 0;
        }

        var name = countryNames[i];
        countryArray[name] = country;
      }

      conflicts.forEach(function(c) {
        if(countryNames.indexOf(c.COUNTRY) !== -1) {
          if(!isNaN(parseInt(c.FATALITIES)) && parseInt(c.YEAR) >= baseYear && parseInt(c.YEAR) < endYear) {
            countryArray[c.COUNTRY].casualties[c.YEAR] += parseInt(c.FATALITIES);
          }
        }
      });

      console.log(countryArray);

      countryNames.forEach(function(n) {
        var code = codes[n];
        var numberOfRefugees = countryArray[n].casualties[year];
        series.push([code, numberOfRefugees])
      });

      var onlyValues = series.map(function(obj){ return obj[1]; });
      var minValue = Math.min.apply(null, onlyValues), maxValue = Math.max.apply(null, onlyValues);

      // color palette
      var paletteScale = d3.scale.linear()
              .domain([minValue,maxValue])
              .range(["#EFEFFF","#02386F"]);

      series.forEach(function(item){ //
          var iso = item[0], value = item[1];
          dataset[iso] = { numberOfThings: value, fillColor: paletteScale(value) };
      });

      d3.csv("countries.csv", function(countries) {
        countries.forEach(function(c) {
          longs[c.country] = parseFloat(c.longitude);
          lats[c.country] = parseFloat(c.latitude);
          transitMatrix[c.country] = {};
          countries.forEach(function(c2) {
            transitMatrix[c.country][c2.country] = 0;
          });
        });

        d3.csv('3countries.csv', function(migrations) {
          migrations.forEach(function(m) {
            transitMatrix[m.origin][m.destination] += parseInt(m.number);
          });



          countryNames.forEach(function(c) {
            countries.forEach(function(c2) {
              if(transitMatrix[c] !== undefined) {
                if(transitMatrix[c][c2.country] > 100) {
                  var arc = {};
                  console.log(lats[c2.country]);

                  arc.origin = {
                    latitude: lats[c],
                    longitude: longs[c]
                  };
                  arc.destination = {
                    latitude: lats[c2.country],
                    longitude: longs[c2.country]
                  };
                  arcs.push(arc);
                }
              }
            });
          });

          var map = new Datamap({
            element: document.getElementById('container'),
            projection: 'mercator',
            fills: { defaultFill: '#F5F5F5' },
            data: dataset,
            geographyConfig: {
                borderColor: '#DEDEDE',
                highlightBorderWidth: 2,
                // don't change color on mouse hover
                highlightFillColor: function(geo) {
                    return geo['fillColor'] || '#F5F5F5';
                },
                // only change border
                highlightBorderColor: '#B7B7B7'
            }
          });

          map.arc(arcs, {
            greatArc: true,
            animationSpeed: 1
          });
          
          console.log(arcs);
        });

      });

    });

            // map.arc([{
            //   origin: {
            //     latitude: lats['Algeria'],
            //     longitude: longs['Algeria']
            //   },
            //   destination: {
            //     latitude: lats['France'],
            //     longitude: longs['France']
            //   }
            //   }], {
            //     greatArc: true,
            //     animationSpeed: 2000
            // });
      //   });
      // };


      /////// Parallel Coordinates //////

      // var m = [30, 10, 10, 10],
      //     w = 960 - m[1] - m[3],
      //     h = 600 - m[0] - m[2];

      // var x = d3.scale.ordinal().rangePoints([0, w], 1),
      //     y = {},
      //     dragging = {};

      // var line = d3.svg.line(),
      //     axis = d3.svg.axis().orient("left"),
      //     background,
      //     foreground;

      // var svg = d3.select("body").append("svg:svg")
      //     .attr("width", w + m[1] + m[3])
      //     .attr("height", h + m[0] + m[2])
      //   .append("svg:g")
      //     .attr("transform", "translate(" + m[3] + "," + m[0] + ")");

      // d3.csv("cambodiaOut.csv", function(cars) {

      //   // Extract the list of dimensions and create a scale for each.
      //   x.domain(dimensions = d3.keys(cars[0]).filter(function(d) {

      //     if(d === "origin") return false;

      //     if(d === "destination") {
      //         y[d] = d3.scale.ordinal()
      //           .domain(cars.map(function(p) { return p[d]; }))
      //           .rangePoints([h, 0]);

      //     }
      //     else {
      //         y[d] = d3.scale.linear()
      //           .domain(d3.extent(cars, function(p) { return +p[d]; }))
      //           .range([h, 0]);
      //     }

      //     return true;

      //     return d != "origin" && d != "destination" && (y[d] = d3.scale.linear()
      //         .domain(d3.extent(cars, function(p) { return +p[d]; }))
      //         .range([h, 0]));
      //   }));

      //   // Add grey background lines for context.
      //   background = svg.append("svg:g")
      //       .attr("class", "background")
      //     .selectAll("path")
      //       .data(cars)
      //     .enter().append("svg:path")
      //       .attr("d", path);

      //   // stroke with color switch
      //   foreground = svg.append("svg:g")
      //       .attr("class", "foreground")
      //     .selectAll("path")
      //       .data(cars)
      //     .enter().append("svg:path")
      //       .attr("d", path)
      //       .style("stroke", function(d) {
      //        if (d.destination.indexOf("United States") > -1)
      //          return "red"
      //        else
      //          return "steelblue"
      //       });

      //   // Add a group element for each dimension.
      //   var g = svg.selectAll(".dimension")
      //       .data(dimensions)
      //     .enter().append("svg:g")
      //       .attr("class", "dimension")
      //       .attr("transform", function(d) { return "translate(" + x(d) + ")"; })
      //       .call(d3.behavior.drag()
      //         .on("dragstart", function(d) {
      //           dragging[d] = this.__origin__ = x(d);
      //           background.attr("visibility", "hidden");
      //         })
      //         .on("drag", function(d) {
      //           dragging[d] = Math.min(w, Math.max(0, this.__origin__ += d3.event.dx));
      //           foreground.attr("d", path);
      //           dimensions.sort(function(a, b) { return position(a) - position(b); });
      //           x.domain(dimensions);
      //           g.attr("transform", function(d) { return "translate(" + position(d) + ")"; })
      //         })
      //         .on("dragend", function(d) {
      //           delete this.__origin__;
      //           delete dragging[d];
      //           transition(d3.select(this)).attr("transform", "translate(" + x(d) + ")");
      //           transition(foreground)
      //               .attr("d", path);
      //           background
      //               .attr("d", path)
      //               .transition()
      //               .delay(500)
      //               .duration(0)
      //               .attr("visibility", null);
      //         }));

      //   // Add an axis and title.
      //   g.append("svg:g")
      //       .attr("class", "axis")
      //       .each(function(d) { d3.select(this).call(axis.scale(y[d])); })
      //     .append("svg:text")
      //       .attr("text-anchor", "middle")
      //       .attr("y", -9)
      //       .text(String);

      //   // Add and store a brush for each axis.
      //   g.append("svg:g")
      //       .attr("class", "brush")
      //       .each(function(d) { d3.select(this).call(y[d].brush = d3.svg.brush().y(y[d]).on("brush", brush)); })
      //     .selectAll("rect")
      //       .attr("x", -8)
      //       .attr("width", 16);
      // });

      // function position(d) {
      //   var v = dragging[d];
      //   return v == null ? x(d) : v;
      // }

      // function transition(g) {
      //   return g.transition().duration(500);
      // }

      // // Returns the path for a given data point.
      // function path(d) {
      //   return line(dimensions.map(function(p) { return [position(p), y[p](d[p])]; }));
      // }

      // // Handles a brush event, toggling the display of foreground lines.
      // function brush() {
      //   var actives = dimensions.filter(function(p) { return !y[p].brush.empty(); }),
      //       extents = actives.map(function(p) { return y[p].brush.extent(); });
      //   foreground.style("display", function(d) {
      //     return actives.every(function(p, i) {
      //       return extents[i][0] <= d[p] && d[p] <= extents[i][1];
      //     }) ? null : "none";
      //   });
      // }

    </script>
  </body>
</html>